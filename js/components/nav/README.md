# Custom Navigation Component
Это полезный кастомный элемент, реализующий логику навигации по ссылкам, и определение активной ссылки при скролле страницы.
Это навигационный компонент, который использует пользовательские HTML-элементы. Он имеет логику для создания списка пунктов, с учетом набора переданных внутрь узлов.

## Зависимости
Компонент способен отслеживать `scroll` для элеменов со свойствами `overflow-y: scroll`. Чтобы он начал следить за элементом
необходимо добавить ему модификатор (класс) `_scrollable`. Если компонент его не найдет, он будет отслеживать событие `scroll` у 
объекта `window`.

## Класс `NavComponent`
`NavComponent` отнаследован от встроенного в браузер класса `HTMLElement` и содержит набор методов и функций, которые реализуют логику определения активной ссылки, обработку событий клика по ссылкам и скролла страницы.

Функция `connectedCallback` автоматически вызывается браузером при подключении элемента к странице и добавления его в DOM-дерево. В данном случае, в эту функцию добавлена логика рендеринга компонента и подписка на события.

Функция `#compareSectionPosition` проверяет наличие перекрытия и вызывает функцию выбора ссылки по индексу.

Функция `#detectSection` состоит из трех составных функций (`findTargetAnchorIdes`, `findSections` и `convertToMap`), которые помогают обнаруживать ссылки на странице, сопоставлять их с их соответствующими секциями и хранить их в виде отображения (Map).

Функция `#subscribeOnLinkClick` отслеживает клик по `li` элементу и устанавливает для этого элемента атрибут `'is-active'` в `'true'`.

Функция `#selectLinkByIndex` устанавливает атрибут `'is-active'` в `'false'` для всех `li` элементов, имеющих другой индекс.

## Обработчики событий ##
### #onSlotChange({target}) ###
Этот обработчик событий вызывается при срабатывании события изменения слота. Он создает список навигационных элементов из переданных узлов из цели события (слота). Если поле #linksToSections не определено, он вызывает метод #detectSection.

## Описание методов ##
### createListContainer(providedNodes) ###
Создает контейнер списка (маркированный список), куда будут добавлены элементы списка. Принимает в качестве аргумента providedNodes и возвращает объект с providedNodes и listNode (элемент ul).

### createList({providedNodes, listNode}) ###
Принимает объект, содержащий providedNodes и listNode. Перебирает узлы, создает элемент списка (li) для каждого узла и добавляет его в listNode. Каждому элементу списка присваивается пользовательский атрибут 'index', соответствующий его позиции в массиве. Возвращает полученный listNode.

### carriedClearSlot(slot) ###
Эта функция принимает элемент слота и возвращает функцию, которая очищает HTML внутри предоставленного слота, а затем возвращает его.

### carriedAppendList(root) ###
Эта функция принимает корневой элемент (обычно контейнер списка) и возвращает функцию, которая добавляет предоставленный элемент в корневой элемент.

### #render() ###
Этот метод используется для отрисовки шаблона внутри компонента. Создает элемент шаблона, назначает HTML содержимое, клонирует узел и добавляет его в корень Shadow DOM. Затем инициализирует ссылки #slot и #list на элементы слота и класса .nav соответственно.

### disconnectedCallback() ###
Этот метод жизненного цикла отменяет все связанные с компонентом события, когда элемент удаляется из DOM-дерева. Инвокация метода removeListeners на каждом из обработчиков событий в #listeners.

## Итого ##
Данный компонент использует несколько современных функций JavaScript и веб-API. Он обрабатывает событие изменение слота, чтобы динамически создавать навигационные элементы. Он также очищает ресурсы при отключении путем удаления прослушивателей, предотвращая потенциальные утечки памяти. Этот компонент является хорошей отправной точкой для создания более сложных компонентов, связанных с навигацией.

## События
`nav-element` может взаимодействовать с различными событиями, в том числе: `events.LINK_CLICKED`, `events.ON_SLOT_CHANGE`, `events.SCROLL`.

## CSS переменные
`nav-element` не использует CSS переменные для задания стилей.


## Как использовать
Для использования данного компонента вам нужно зарегистрировать его в вашем JavaScript коде:

```javascript
customElements.define(NavComponent.name, NavComponent);
```

После этого вы сможете использовать его в вашем HTML коде как обычный HTML-тэг:

```html
    <nav-element></nav-element>
```